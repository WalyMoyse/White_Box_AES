#include <stdio.h>
#include <stdlib.h>
#include <err.h>
#include <stdbool.h>
#include <unistd.h>
#include "../include/cipher.h"
#include "../include/tools.h"


const unsigned char sbox[256] = { // table used for SubBytes
    // 0     1    2      3     4    5     6     7      8    9     A      B    C     D     E     F
    0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,  // 0
    0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,  // 1
    0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,  // 2
    0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,  // 3
    0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,  // 4
    0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,  // 5
    0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,  // 6
    0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,  // 7
    0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,  // 8
    0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,  // 9
    0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,  // A
    0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,  // B
    0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,  // C
    0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,  // D
    0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,  // E
    0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16}; // F


const unsigned char power_generator[256] = { // tableau containing the power of a generator of the field used for mixcolumn
   
    0x01, 0x03, 0x05, 0x0f, 0x11, 0x33, 0x55, 0xff, 0x1a, 0x2e, 0x72, 0x96, 0xa1, 0xf8, 0x13, 0x35,
    0x5f, 0xe1, 0x38, 0x48, 0xd8, 0x73, 0x95, 0xa4, 0xf7, 0x02, 0x06, 0x0a, 0x1e, 0x22, 0x66, 0xaa, 
    0xe5, 0x34, 0x5c, 0xe4, 0x37, 0x59, 0xeb, 0x26, 0x6a, 0xbe, 0xd9, 0x70, 0x90, 0xab, 0xe6, 0x31, 
    0x53, 0xf5, 0x04, 0x0c, 0x14, 0x3c, 0x44, 0xcc, 0x4f, 0xd1, 0x68, 0xb8, 0xd3, 0x6e, 0xb2, 0xcd, 
    0x4c, 0xd4, 0x67, 0xa9, 0xe0, 0x3b, 0x4d, 0xd7, 0x62, 0xa6, 0xf1, 0x08, 0x18, 0x28, 0x78, 0x88, 
    0x83, 0x9e, 0xb9, 0xd0, 0x6b, 0xbd, 0xdc, 0x7f, 0x81, 0x98, 0xb3, 0xce, 0x49, 0xdb, 0x76, 0x9a, 
    0xb5, 0xc4, 0x57, 0xf9, 0x10, 0x30, 0x50, 0xf0, 0x0b, 0x1d, 0x27, 0x69, 0xbb, 0xd6, 0x61, 0xa3, 
    0xfe, 0x19, 0x2b, 0x7d, 0x87, 0x92, 0xad, 0xec, 0x2f, 0x71, 0x93, 0xae, 0xe9, 0x20, 0x60, 0xa0, 
    0xfb, 0x16, 0x3a, 0x4e, 0xd2, 0x6d, 0xb7, 0xc2, 0x5d, 0xe7, 0x32, 0x56, 0xfa, 0x15, 0x3f, 0x41, 
    0xc3, 0x5e, 0xe2, 0x3d, 0x47, 0xc9, 0x40, 0xc0, 0x5b, 0xed, 0x2c, 0x74, 0x9c, 0xbf, 0xda, 0x75, 
    0x9f, 0xba, 0xd5, 0x64, 0xac, 0xef, 0x2a, 0x7e, 0x82, 0x9d, 0xbc, 0xdf, 0x7a, 0x8e, 0x89, 0x80, 
    0x9b, 0xb6, 0xc1, 0x58, 0xe8, 0x23, 0x65, 0xaf, 0xea, 0x25, 0x6f, 0xb1, 0xc8, 0x43, 0xc5, 0x54, 
    0xfc, 0x1f, 0x21, 0x63, 0xa5, 0xf4, 0x07, 0x09, 0x1b, 0x2d, 0x77, 0x99, 0xb0, 0xcb, 0x46, 0xca, 
    0x45, 0xcf, 0x4a, 0xde, 0x79, 0x8b, 0x86, 0x91, 0xa8, 0xe3, 0x3e, 0x42, 0xc6, 0x51, 0xf3, 0x0e, 
    0x12, 0x36, 0x5a, 0xee, 0x29, 0x7b, 0x8d, 0x8c, 0x8f, 0x8a, 0x85, 0x94, 0xa7, 0xf2, 0x0d, 0x17, 
    0x39, 0x4b, 0xdd, 0x7c, 0x84, 0x97, 0xa2, 0xfd, 0x1c, 0x24, 0x6c, 0xb4, 0xc7, 0x52, 0xf6, 0x01
};

const unsigned char inv_power_generator[256] = { // the reciprocal array of power_generator

    0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03, 
    0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1, 
    0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78, 
    0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e, 
    0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38, 
    0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10, 
    0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba, 
    0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57, 
    0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8, 
    0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0, 
    0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7, 
    0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d, 
    0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1, 
    0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab, 
    0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5, 
    0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07};

const unsigned char galois_c[size_block] = { // the matrix which is multipled by a state in mixcolumns
    0x02, 0x01, 0x01, 0x03,
    0x03, 0x02, 0x01, 0x01,
    0x01, 0x03, 0x02, 0x01,
    0x01, 0x01, 0x03, 0x02
};



unsigned char GetSboxValue(unsigned char c) { // sbox is needed in others .c files 
    return sbox[c]; 
}


int GetPowerGenerator(unsigned char c) { // This function return the value n such that c is equal to the generator^n
    return inv_power_generator[c];
}

/*
@param a a,d b : unsigned char each representing an element in the feld used in mixcolumns
@return the unsigned char corresponding to a*b in this field
*/
unsigned char FastMult(unsigned char a, unsigned char b) {
    unsigned char res;
    if(a == 0 || b == 0) {
        res = 0;
    }
    else {
        int i = GetPowerGenerator(a); // a = generator^i
        int j = GetPowerGenerator(b); // b = generator^j
        res = power_generator[(i + j) % 255]; // a*b = generator^(i+j)
    }
    return res;
}
/*

This function multiply a state by a matrix in the field used in MixColumns
@param state : the current state
@param mixcol : a matrix 
*/
void State_mult(unsigned char* state, const unsigned char* mixcol) {
    int i;
    int j;
    int k;
    unsigned char temp[size_block]; // creation of a copy of the state
    for(i = 0; i < size_block; i++) {
        temp[i] = state[i];
        state[i] = 0;
    }

    for(i = 0 ; i < 4 ; i++) {
        for(j = 0 ; j < 4 ; j++) {
            for(k = 0 ; k < 4 ; k++) {
                state[i + j * 4] ^= FastMult(mixcol[i + k * 4], temp[k + j * 4]); // classic matrix multiplication but addition are xor and multiplication are our special multiplication
            }
        }
    }
}

int get_nround(int key_size) { // This function returns the number of round performed depending on the size of the key
    switch(key_size) {
        case 16 :
            return 10;
        case 24 :
            return 12;
        case 32 :
            return 14;
        default :
             errx(EXIT_FAILURE, "Unsupported size key \n");
    }
}

void SubBytes(unsigned char* state) { // This function apply the SubBytes transormation to a state
    int i;
    for(i = 0; i < size_block; i++) {
        state[i] = GetSboxValue(state[i]);
    }
}

void ShiftRows(unsigned char* state) { // This function apply the ShiftRows transformation to a state
    int i;
    int j;
    int k;
    unsigned char c;
    for(k = 0; k < 4; k++) {
        for(i = 0; i < k; i++) {
            c = state[k];
            for(j = 0; j < 3; j++) {
                state[k + 4 * j] = state[k + 4 * (j + 1)];  // shift
            }
            state[k + 12] = c;
        }
    }
}

void MixColumns(unsigned char* state){ // This function apply the MixColumns transformation to a state
    State_mult(state,galois_c); // Just the multiplication of the state and galois_c
}

void AddRoundKey(unsigned char* state, unsigned char* expandedkey, int step) { // This function apply the AddRoundKey transformation to a state depending on the step we are in
    int i;
    for(i = 0; i < size_block ; i++) {
        state[i] ^= expandedkey[size_block * step + i]; // Just a Xor with the corresponding part of the expended key
    }
}

void cipher_block(unsigned char* state, unsigned char* expkey, int Nround) { // This function is applying the AES encryption algorithm depending on the expended, and the size of the key and the number of round
    int step = 0;
    AddRoundKey(state, expkey, step); // First applicattion of AddRoundKey
    for(step = 1; step < Nround; step++) { // Nround cycle of appplication of all 4 transformation
        SubBytes(state);
        ShiftRows(state);
        MixColumns(state);
        AddRoundKey(state, expkey, step);
    }
    SubBytes(state); // Last step without mixcolumns
    ShiftRows(state);
    AddRoundKey(state, expkey, Nround);
}

int applyXOR(unsigned char XOR[16][16], int t1, int t2) { // This function return the XOR of t1 and t2 using 8 XOR table (one for each nibble of t1 and t2)
    int res = 0;
    int a = (unsigned int)XOR[(t1 >> 28) & 0xF][(t2 >> 28) & 0xF] ; // XOR their first 4 bits
    int b = (unsigned int)XOR[(t1 >> 24) & 0xF][(t2 >> 24) & 0xF] ; // XOR their next 4 bits
    int c = (unsigned int)XOR[(t1 >> 20) & 0xF][(t2 >> 20) & 0xF] ; // until bits are Xored
    int d = (unsigned int)XOR[(t1 >> 16) & 0xF][(t2 >> 16) & 0xF] ;
    int e = (unsigned int)XOR[(t1 >> 12) & 0xF][(t2 >> 12) & 0xF] ;
    int f = (unsigned int)XOR[(t1 >> 8) & 0xF][(t2 >> 8) & 0xF] ;
    int g = (unsigned int)XOR[(t1 >> 4) & 0xF][(t2 >> 4) & 0xF] ;
    int h = (unsigned int)XOR[(t1) & 0xF][(t2) & 0xF] ;
    res = (a << 28) | (b << 24) | (c << 20) | (d << 16) | (e << 12) | (f << 8) | (g << 4) | h ; // reconstruction of the result
    return res;
}

void WBC_AES_No_MixBij(unsigned char block[16], unsigned char tbox[16][256], unsigned int TBoxesTyiTables[9][16][256], unsigned char XOR[9][192][16][16]) { 
    // Apply AES on block using the tables-based AES implementation
    int i; int r; 
    unsigned int tempres[16]; // will store results of all XOR
    unsigned int tempres2[8];
    unsigned int tempres3[4];
    
    for(r = 0; r < 9; r++) { // same number of round as usual
        ShiftRows(block); // shiftrows
        for(i = 0; i < 16; i++) {
                tempres[i] = TBoxesTyiTables[r][i][block[i]]; // SubBytes, AddRoundKey and a part of MixColumns
        }
        for(i = 0; i < 8; i++) {
            tempres2[i] = applyXOR(XOR[r][i], tempres[2*i], tempres[2*i+1]); // first XOR step for MixColumns
        }
        for(i = 0; i < 4; i++) {
            tempres3[i] = applyXOR(XOR[r][i], tempres2[2*i], tempres2[2*i+1]); // 2nnd XOR step for MixColumns
        }

        for(i = 0; i < 4; i++) {
            block[i*4] = (unsigned char)(tempres3[i] >> 24 & 0xFF) ; // reconstruction of the result
            block[i*4 + 1] = (unsigned char)(tempres3[i] >> 16 & 0xFF) ;
            block[i*4 + 2] = (unsigned char)(tempres3[i] >> 8 & 0xFF) ;
            block[i*4 + 3] = (unsigned char)(tempres3[i]  & 0xFF) ;
            }
        }
    //last round
    ShiftRows(block);
    for(i = 0; i < 16; i++) {
        block[i] = tbox[i][block[i]]; 
    }
}

int applyXOR2(unsigned char XOR[9][192][16][16], int t1, int t2,int r, int i) { // This function return the XOR of t1 and t2 using 8 XOR table (one for each nibble of t1 and t2)
    int res = 0;
    int a = (unsigned int)XOR[r][i][(t1 >> 28) & 0xF][(t2 >> 28) & 0xF] ; // XOR their first 4 bits
    int b = (unsigned int)XOR[r][i + 1][(t1 >> 24) & 0xF][(t2 >> 24) & 0xF] ; // XOR their next 4 bits
    int c = (unsigned int)XOR[r][i + 2][(t1 >> 20) & 0xF][(t2 >> 20) & 0xF] ; // until bits are Xored
    int d = (unsigned int)XOR[r][i + 3][(t1 >> 16) & 0xF][(t2 >> 16) & 0xF] ;
    int e = (unsigned int)XOR[r][i + 4][(t1 >> 12) & 0xF][(t2 >> 12) & 0xF] ;
    int f = (unsigned int)XOR[r][i + 5][(t1 >> 8) & 0xF][(t2 >> 8) & 0xF] ;
    int g = (unsigned int)XOR[r][i + 6][(t1 >> 4) & 0xF][(t2 >> 4) & 0xF] ;
    int h = (unsigned int)XOR[r][i + 7][(t1) & 0xF][(t2) & 0xF] ;
    res = (a << 28) | (b << 24) | (c << 20) | (d << 16) | (e << 12) | (f << 8) | (g << 4) | h ; // reconstruction of the result
    return res;
}

void WBC_AES_MixBij(unsigned char block[16], unsigned char XOR[9][192][16][16], unsigned int mixin[10][16][256], unsigned int mixout[9][16][256]) {
    // Apply AES on block using the tables-based AES implementation with the mixing bijections 
    int i; int r; 
    unsigned int tempres[16]; // the beggining follow the same logical
    unsigned int tempres2[8];
    unsigned int tempres3[4];
    int currentXOR;
    
    for(r = 0; r < 9; r++) {
        currentXOR = 0;
        ShiftRows(block); // ShiftRows
        for(i = 0; i < 16; i++) {
                tempres[i] = mixin[r][i][block[i]]; // applying TBoxesTyiTables composed with mixing bijections
        }
        for(i = 0; i < 8; i++) {
            tempres2[i] = applyXOR2(XOR, tempres[2*i], tempres[2*i+1], r, currentXOR); // first Xor for MixColumns
            currentXOR += 8;
        }
        for(i = 0; i < 4; i++) {
            tempres3[i] = applyXOR2(XOR, tempres2[2*i], tempres2[2*i+1], r, currentXOR); // 2nd Xor for MixColumns
            currentXOR += 8;
        }

        for(i = 0; i < 4; i++) {
            tempres[i*4] = tempres3[i] >> 24 & 0xFF ; // We have to apply Mixing table before reconstucing the result
            tempres[i*4 + 1] = tempres3[i] >> 16 & 0xFF ;
            tempres[i*4 + 2] = tempres3[i] >> 8 & 0xFF ;
            tempres[i*4 + 3] = tempres3[i]  & 0xFF ;
            }
        for(i = 0; i < 16; i++) {
            tempres[i] = mixout[r][i][tempres[i]]; // applying the first one
        }

        for(i = 0; i < 8; i++) {
            tempres2[i] = applyXOR2(XOR, tempres[2*i], tempres[2*i+1], r, currentXOR); // Xor for mixing Bijections
            currentXOR +=8;
        }

        for(i = 0; i < 4; i++) {
            tempres3[i] = applyXOR2(XOR, tempres2[2*i], tempres2[2*i+1], r, currentXOR); // 2nd XOR
            currentXOR +=8;
        }

        for(i = 0; i < 4; i++) {
            block[i*4] = (unsigned char)(tempres3[i] >> 24 & 0xFF) ; // ANd now we reconstruct
            block[i*4 + 1] = (unsigned char)(tempres3[i] >> 16 & 0xFF) ;
            block[i*4 + 2] = (unsigned char)(tempres3[i] >> 8 & 0xFF) ;
            block[i*4 + 3] = (unsigned char)(tempres3[i]  & 0xFF) ;
            }
    }

    //last round
    ShiftRows(block);
    for(i = 0; i < 16; i++) {
        block[i] = mixin[9][i][block[i]];
    }
}



