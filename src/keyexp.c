#include <stdio.h>
#include <stdlib.h>
#include <err.h>
#include <stdbool.h>
#include <unistd.h>
#include "../include/cipher.h"
#include "../include/keyexp.h"

unsigned char Rcon[255] = { // The rcon table used for the key expansion

    0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8,
    0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3,
    0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f,
    0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d,
    0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab,
    0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d,
    0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25,
    0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01,
    0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d,
    0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa,
    0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a,
    0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02,
    0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a,
    0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef,
    0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94,
    0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04,
    0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f,
    0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5,
    0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33,
    0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb};

void RotWord(unsigned char* word) { // the function rotword
    int i;
    unsigned char temp = word[0];
    for(i = 0; i < 3; i++) {
        word[i] = word[i+1]; // shift the word
    }
    word[3] = temp;
}

void SubWord(unsigned char* word) { // the function subword
    int i;
     for(i = 0; i < 4; i++) {
        word[i] = GetSboxValue(word[i]); // Using function in cipher.h
    }
}

/*
@param key : the private key
@param key_size : the size of the key in octet
@return : the expanded key used for AES
*/
unsigned char* ExpandKey(unsigned char* key, int key_size) {
    int expkey_size;
    int current_size = 0; // track the size of the expanded key
    int i;
    int rcon = 1;
    switch(key_size) {
        case 16 :
            expkey_size = 176; // size of the expended key in octet depending on the size of the key
            break;
        case 24 :
            expkey_size = 208;
            break;
        case 32 : 
            expkey_size = 240;
            break;
        default :
            errx(EXIT_FAILURE, "Unsupported key size. \n");
    }

    unsigned char *expended_key = malloc(expkey_size * sizeof(unsigned char)); // memory allocation for the expended key
    if(expended_key == NULL) {
        fprintf(stderr, "Failed to allocate memory\n");
        return NULL;
    }

    unsigned char last_word[4]; // track the last word of the expanded key after each step

    for(i = 0; i < key_size; i++) {
        expended_key[i] = key[i]; // the beggining of the expanded key is just the key
    }
    current_size = key_size;
    for(i = 0; i < 4; i++) {
            last_word[i] = expended_key[current_size - 4 + i]; // updating last_word
    }
  
    while(current_size < expkey_size) { // expand the key until it has the size needed
        

        if(current_size % key_size == 0) {
            RotWord(last_word);
            SubWord(last_word);
            last_word[0] ^= Rcon[rcon];
            rcon++;
        }
        if((key_size == 32) && (current_size % key_size == 16)) {
            SubWord(last_word); // extra step for AES 256
        }
        for(i = 0; i < 4; i ++) {
            last_word[i] ^= expended_key[current_size - key_size + i];
            expended_key[current_size + i] = last_word[i];
        }
        current_size += 4;
    }
    return expended_key; // result
}
